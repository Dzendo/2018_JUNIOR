package com.example.day_32_1_sql_k.data

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import android.util.Log
import com.example.day_32_1_sql_k.data.HotelContract.GuestEntry

/*class HotelDbHelper(context: Context?, DATABASE_NAME: String?, factory: SQLiteDatabase.CursorFactory?, DATABASE_VERSION: Int) :
        SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
// преобразованный из java забраковал
    override fun onCreate(db: SQLiteDatabase) {
    }
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}*/


class HotelDbHelper (context: Context) :
        SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {
    // Третий параметр null в суперклассе используется для работы с курсорами.
    // Сейчас их не используем, поэтому оставим в покое.

    companion object {
        val LOG_TAG = HotelDbHelper::class.java.simpleName
        // * Имя файла базы данных
        private val DATABASE_NAME = "hotel.db"
        //  * Версия базы данных. При изменении схемы увеличить на единицу
        private val DATABASE_VERSION = 1
    }
    override fun onCreate(db: SQLiteDatabase) {
        // здесь создаётся сама база данных с необходимыми данными для работы.
        // Строка для создания таблицы
        val SQL_CREATE_GUESTS_TABLE = ("CREATE TABLE " + GuestEntry.TABLE_NAME + " ("
                + GuestEntry._ID + " INTEGER PRIMARY KEY AUTOINCREMENT, "
                + GuestEntry.COLUMN_NAME + " TEXT NOT NULL, "
                + GuestEntry.COLUMN_CITY + " TEXT NOT NULL, "
                + GuestEntry.COLUMN_GENDER + " INTEGER NOT NULL DEFAULT 3, "
                + GuestEntry.COLUMN_AGE + " INTEGER NOT NULL DEFAULT 0);")

        // Запускаем создание таблицы
        db.execSQL(SQL_CREATE_GUESTS_TABLE)
    }

    /**
     * Вызывается при обновлении схемы базы даннных
     */
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
// Запишем в журнал
        Log.w("SQLite", "Обновляемся с версии " + oldVersion + " на версию " + newVersion)

        // Удаляем старую таблицу и создаём новую

       // db.execSQL("DROP TABLE IF IT EXISTS " + DATABASE_TABLE)
        // Создаём новую таблицу
        onCreate(db);
    }

}

// Как вы уже догадались, константа DATABASE_NAME отвечает за имя файла,
// в котором будет храниться база данных приложения.
// Можно придумать любое имя и обойтись без расширения.
// Но мне так привычнее.
//
//Вторая константа DATABASE_VERSION требует дополнительных объяснений.
// Она отвечает за номер версии базы.
// Принцип её работы схож с номером версий самого приложения.
// Когда мы видим, что вышла новая версия Chrome 33, то понимаем, что пора обновляться.
// Аналогично поступает и само приложение, когда замечает, что номер версии базы стал другим.
// Как только программа заметила обновление номера базы,
// она запускает метод onUpgrade(), который у нас сформировался автоматически.
// В этом методе необходимо разместить код, который должен сработать при обновлении базы.

// Метод onCreate()
//Метод вызывается, если в устройстве нет базы данных и наш класс должен создать его.
// Как мы помним, у метода есть параметр db, который относится к классу SQLiteDatabase.
// У класса есть специальный метод execSQL(),
// которому нужно передать запрос (SQL-скрипт) для создания таблицы.
// Для создания таблицы в SQL используется команда CREATE TABLE ....
// Для удобства вынесем команду в отдельную строку.
// Аналогично поступим с командой DROP TABLE.
// Так как строка очень длинная и состоит из множества строковых переменных,
// которые нужно соединить в одну цепочку, то поступают следующим образом.
// Создаём ещё одну строковую константу для формирования скрипта и передадим её в метод

//Основная сложность - не пропустить пробелы в запросе.
// Очень часто пропущенный пробел становится источником проблем
// и ваше приложение не может создать таблицу.
// Можете сначала написать сам скрипт создания таблицы,
// а уже потом заменять отдельные слова константами.
// Идентификатор _id всегда должен использовать INTEGER PRIMARY KEY AUTOINCREMENT,
// остальные колонки на ваше усмотрение.

//Теперь нужно объяснить, зачем нужен этот метод onUpgrade().
// Представьте ситуацию, что вы первоначально создали в базе таблицу,
// в которую заносятся имена котов и их электронные адреса и телефоны (продвинутые кошаки).
// Вроде всё замечательно.
// Если нужно поздравить усатых-полосатых с Международным днём кошек,
// который отмечается 1 марта, то проблем нет никаких.
// У вас есть список имён, по которому вы можете пройтись и лично написать каждому письмо.
// Пользователи, скачавшие ваше приложение,
// с удовольствием заполняют базу данных и дружно пишут письма мелким почерком.
// И вдруг до вас дошло, что совершили непростительную ошибку.
// Вы забыли добавить в базу данных даты рождения котов.
// А значит их никто не поздравит и не погладит (((.

// Вы исправляете досадное упущение и выкладываете новую версию программы в открытый доступ.
// Новые пользователи, которые установят программу первый раз,
// радуются жизни - у них есть все необходимые данные для работы.
// Но что делать тем, кто уже работает со старой программой?
// Обновившись, они увидят дополнительное текстовое поле для ввода даты рождения,
// но в старой базе нет колонки для хранения новых данных.
// И ваша программа завершится с ошибкой.
// Полностью удалять и устанавливать новую версию программы тоже не выход
// - тогда пропадут старые данные, что тоже не желательно.
// Для таких случаев вы пишете код в методе onUpgrade(),
// чтобы при обновлении поменялась структура базы данных у старых пользователей.
// Мы позже попробуем смоделировать эту ситуацию.

// Итак, метод onUpgrade() вызывается при несовпадении версий.
// Часто в этом методе просто удаляют существующую таблицу и заменяют её на новую.
// Это самое простое и практичное решение.
// Впрочем, на первых порах, вам вряд ли придётся заниматься подобными делами,
// поэтому метод можно оставить даже пустым

// Когда ваше приложение будет готово,
// то в папке data/data/имя_пакета/databases появится файл hotel.db (позже я вам покажу).
// Этот файл и будет вашей базой данных, в которой будет находиться созданная вами таблица.
// На данный момент в студии нет готового плагина для просмотра таблиц (в Eclipse есть),
// но вроде уже видел плагин от сторонних разработчиков.
// А пока вам придётся скачивать из устройства файл базы данных
// и просматривать его на компьютере специальными программами,
// работающими с SQLite на локальном компьютере
